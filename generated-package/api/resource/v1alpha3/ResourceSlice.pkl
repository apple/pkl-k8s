//===----------------------------------------------------------------------===//
// Copyright Â© 2024-2026 Apple Inc. and the Pkl project authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//===----------------------------------------------------------------------===//

/// ResourceSlice represents one or more resources in a pool of similar resources, managed by a common driver.
///
/// A pool may span more than one ResourceSlice, and exactly how many ResourceSlices comprise a pool is determined by the driver.
///
/// At the moment, the only supported resources are devices with attributes and capacities.
/// Each device in a given pool, regardless of how many ResourceSlices, must have a unique name.
/// The ResourceSlice in which a device gets published may change over time.
/// The unique identifier for a device is the tuple <driver name>, <pool name>, <device name>.
///
/// Whenever a driver needs to update a pool, it increments the pool.Spec.Pool.Generation number and updates all ResourceSlices with that new number and new resource definitions.
/// A consumer must only use ResourceSlices with the highest generation number and ignore all others.
///
/// When allocating all resources in a pool matching certain criteria or when looking for the best solution among several different alternatives, a consumer should check the number of ResourceSlices in a pool (included in each ResourceSlice) to determine whether its view of a pool is complete and if not, should wait until the driver has completed updating the pool.
///
/// For resources that are not local to a node, the node name is not set.
/// Instead, the driver may use a node selector to specify where the devices are available.
///
/// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
@K8sVersion { introducedIn = "1.31"; removedIn = "1.34" }
@ModuleInfo { minPklVersion = "0.25.0" }
open module k8s.api.resource.v1alpha3.ResourceSlice

extends ".../K8sResource.pkl"

import ".../api/core/v1/NodeSelector.pkl"
import ".../api/resource/v1alpha3/DeviceTaint.pkl"
import ".../apimachinery/pkg/apis/meta/v1/ObjectMeta.pkl"

fixed apiVersion: "resource.k8s.io/v1alpha3"

fixed kind: "ResourceSlice"

/// Standard object metadata
metadata: ObjectMeta?

/// Contains the information published by the driver.
///
///
/// Changing the spec automatically increments the metadata.generation number.
spec: ResourceSliceSpec

/// ResourceSliceSpec contains the information published by the driver in one ResourceSlice.
class ResourceSliceSpec {
  /// NodeName identifies the node which provides the resources in this pool.
  ///
  /// A field selector can be used to list only ResourceSlice objects belonging to a certain node.
  ///
  /// This field can be used to limit access from nodes to ResourceSlices with the same node name.
  /// It also indicates to autoscalers that adding new nodes of the same type as some old node might also make new resources available.
  ///
  /// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
  /// This field is immutable.
  nodeName: String?

  /// Driver identifies the DRA driver providing the capacity information.
  ///
  /// A field selector can be used to list only ResourceSlice objects with a certain driver name.
  ///
  /// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
  /// This field is immutable.
  driver: String

  /// PerDeviceNodeSelection defines whether the access from nodes to resources in the pool is set on the ResourceSlice level or on each device.
  ///
  /// If it is set to true, every device defined the ResourceSlice must specify this individually.
  ///
  /// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
  @K8sVersion { introducedIn = "1.33" }
  perDeviceNodeSelection: Boolean?

  /// Devices lists some or all of the devices in this pool.
  ///
  ///
  /// Must not have more than 128 entries.
  devices: Listing<Device>?

  /// Pool describes the pool that this ResourceSlice belongs to.
  pool: ResourcePool

  /// SharedCounters defines a list of counter sets, each of which has a name and a list of counters available.
  ///
  ///
  /// The names of the SharedCounters must be unique in the ResourceSlice.
  ///
  /// The maximum number of SharedCounters is 32.
  @K8sVersion { introducedIn = "1.33" }
  sharedCounters: Listing<CounterSet>?

  /// AllNodes indicates that all nodes have access to the resources in the pool.
  ///
  ///
  /// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
  allNodes: Boolean?

  /// NodeSelector defines which nodes have access to the resources in the pool, when that pool is not limited to a single node.
  ///
  ///
  /// Must use exactly one term.
  ///
  /// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
  nodeSelector: NodeSelector?
}

/// Device represents one individual hardware instance that can be selected based on its attributes.
///
/// Besides the name, exactly one field must be set.
class Device {
  /// Name is unique identifier among all devices managed by the driver in the pool.
  ///
  /// It must be a DNS label.
  name: String

  /// Basic defines one device instance.
  basic: BasicDevice?
}

/// BasicDevice defines one device instance.
class BasicDevice {
  /// NodeName identifies the node where the device is available.
  ///
  ///
  /// Must only be set if Spec.PerDeviceNodeSelection is set to true.
  /// At most one of NodeName, NodeSelector and AllNodes can be set.
  @K8sVersion { introducedIn = "1.33" }
  nodeName: String?

  /// ConsumesCounters defines a list of references to sharedCounters and the set of counters that the device will consume from those counter sets.
  ///
  ///
  /// There can only be a single entry per counterSet.
  ///
  /// The total number of device counter consumption entries must be <= 32.
  /// In addition, the total number in the entire ResourceSlice must be <= 1024 (for example, 64 devices with 16 counters each).
  @K8sVersion { introducedIn = "1.33" }
  consumesCounters: Listing<DeviceCounterConsumption>?

  /// Attributes defines the set of attributes for this device.
  ///
  /// The name of each attribute must be unique in that set.
  ///
  /// The maximum number of attributes and capacities combined is 32.
  attributes: Mapping<String, DeviceAttribute>?

  /// If specified, these are the driver-defined taints.
  ///
  ///
  /// The maximum number of taints is 4.
  ///
  /// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
  @K8sVersion { introducedIn = "1.33" }
  taints: Listing<DeviceTaint>?

  /// AllNodes indicates that all nodes have access to the device.
  ///
  ///
  /// Must only be set if Spec.PerDeviceNodeSelection is set to true.
  /// At most one of NodeName, NodeSelector and AllNodes can be set.
  @K8sVersion { introducedIn = "1.33" }
  allNodes: Boolean?

  /// Capacity defines the set of capacities for this device.
  ///
  /// The name of each capacity must be unique in that set.
  ///
  /// The maximum number of attributes and capacities combined is 32.
  capacity: Mapping<String, Quantity>?

  /// NodeSelector defines the nodes where the device is available.
  ///
  ///
  /// Must only be set if Spec.PerDeviceNodeSelection is set to true.
  /// At most one of NodeName, NodeSelector and AllNodes can be set.
  @K8sVersion { introducedIn = "1.33" }
  nodeSelector: NodeSelector?
}

/// DeviceCounterConsumption defines a set of counters that a device will consume from a CounterSet.
class DeviceCounterConsumption {
  /// Counters defines the Counter that will be consumed by the device.
  ///
  ///
  /// The maximum number counters in a device is 32.
  /// In addition, the maximum number of all counters in all devices is 1024 (for example, 64 devices with 16 counters each).
  counters: Mapping<String, Counter>

  /// CounterSet defines the set from which the counters defined will be consumed.
  counterSet: String
}

/// Counter describes a quantity associated with a device.
class Counter {
  /// Value defines how much of a certain device counter is available.
  value: Quantity
}

/// DeviceAttribute must have exactly one field set.
class DeviceAttribute {
  /// BoolValue is a true/false value.
  bool: Boolean?

  /// StringValue is a string.
  ///
  /// Must not be longer than 64 characters.
  string: String?

  /// VersionValue is a semantic version according to semver.org spec 2.0.0.
  ///
  /// Must not be longer than 64 characters.
  version: String?

  /// IntValue is a number.
  int: Int?
}

/// ResourcePool describes the pool that ResourceSlices belong to.
class ResourcePool {
  /// Generation tracks the change in a pool over time.
  ///
  /// Whenever a driver changes something about one or more of the resources in a pool, it must change the generation in all ResourceSlices which are part of that pool.
  /// Consumers of ResourceSlices should only consider resources from the pool with the highest generation number.
  /// The generation may be reset by drivers, which should be fine for consumers, assuming that all ResourceSlices in a pool are updated to match or deleted.
  ///
  /// Combined with ResourceSliceCount, this mechanism enables consumers to detect pools which are comprised of multiple ResourceSlices and are in an incomplete state.
  generation: Int

  /// ResourceSliceCount is the total number of ResourceSlices in the pool at this generation number.
  ///
  /// Must be greater than zero.
  ///
  /// Consumers can use this to check whether they have seen all ResourceSlices belonging to the same pool.
  resourceSliceCount: Int

  /// Name is used to identify the pool.
  ///
  /// For node-local devices, this is often the node name, but this is not required.
  ///
  /// It must not be longer than 253 characters and must consist of one or more DNS sub-domains separated by slashes.
  /// This field is immutable.
  name: String
}

/// CounterSet defines a named set of counters that are available to be used by devices defined in the ResourceSlice.
///
///
/// The counters are not allocatable by themselves, but can be referenced by devices.
/// When a device is allocated, the portion of counters it uses will no longer be available for use by other devices.
class CounterSet {
  /// Counters defines the counters that will be consumed by the device.
  ///
  /// The name of each counter must be unique in that set and must be a DNS label.
  ///
  /// To ensure this uniqueness, capacities defined by the vendor must be listed without the driver name as domain prefix in their name.
  /// All others must be listed with their domain prefix.
  ///
  /// The maximum number of counters is 32.
  counters: Mapping<String, Counter>

  /// CounterSet is the name of the set from which the counters defined will be consumed.
  name: String
}
