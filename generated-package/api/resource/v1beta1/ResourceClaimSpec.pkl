//===----------------------------------------------------------------------===//
// Copyright © 2024-2025 Apple Inc. and the Pkl project authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//===----------------------------------------------------------------------===//

/// ResourceClaimSpec defines what is being requested in a ResourceClaim and how to configure it.
@K8sVersion { introducedIn = "1.32" }
@ModuleInfo { minPklVersion = "0.25.0" }
module k8s.api.resource.v1beta1.ResourceClaimSpec

extends ".../K8sObject.pkl"

import ".../api/resource/v1beta1/DeviceSelector.pkl"
import ".../api/resource/v1beta1/DeviceToleration.pkl"
import ".../api/resource/v1beta1/OpaqueDeviceConfiguration.pkl"

/// Devices defines how to request devices.
devices: DeviceClaim?

/// DeviceClaim defines how to request devices with a ResourceClaim.
class DeviceClaim {
  /// Requests represent individual requests for distinct devices which must all be satisfied.
  ///
  /// If empty, nothing needs to be allocated.
  requests: Listing<DeviceRequest>?

  /// This field holds configuration for multiple potential drivers which could satisfy requests in this claim.
  ///
  /// It is ignored while allocating the claim.
  config: Listing<DeviceClaimConfiguration>?

  /// These constraints must be satisfied by the set of devices that get allocated for the claim.
  constraints: Listing<DeviceConstraint>?
}

/// DeviceRequest is a request for devices required for a claim.
///
/// This is typically a request for a single resource like a device, but can also ask for several identical devices.
class DeviceRequest {
  /// AllocationMode and its related fields define how devices are allocated to satisfy this request.
  ///
  /// Supported values are:
  ///
  /// - ExactCount: This request is for a specific number of devices.
  ///   This is the default.
  /// The exact number is provided in the
  ///   count field.
  ///
  /// - All: This request is for all of the matching devices in a pool.
  ///   At least one device must exist on the node for the allocation to succeed.
  ///   Allocation will fail if some devices are already allocated,
  ///   unless adminAccess is requested.
  ///
  /// If AllocationMode is not specified, the default mode is ExactCount.
  /// If the mode is ExactCount and count is not specified, the default count is one.
  /// Any other requests must specify this field.
  ///
  /// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
  ///
  /// More modes may get added in the future.
  /// Clients must refuse to handle requests with unknown modes.
  allocationMode: String?

  /// DeviceClassName references a specific DeviceClass, which can define additional configuration and selectors to be inherited by this request.
  ///
  ///
  /// A class is required if no subrequests are specified in the firstAvailable list and no class can be set if subrequests are specified in the firstAvailable list.
  /// Which classes are available depends on the cluster.
  ///
  /// Administrators may use this to restrict which devices may get requested by only installing classes with selectors for permitted devices.
  /// If users are free to request anything without restrictions, then administrators can create an empty DeviceClass for users to reference.
  deviceClassName: String?

  /// AdminAccess indicates that this is a claim for administrative access to the device(s).
  ///
  /// Claims with AdminAccess are expected to be used for monitoring or other management services for a device.
  /// They ignore all ordinary claims to the device with respect to access modes and any resource allocations.
  ///
  /// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
  ///
  /// This is an alpha field and requires enabling the DRAAdminAccess feature gate.
  /// Admin access is disabled if this field is unset or set to false, otherwise it is enabled.
  adminAccess: Boolean?

  /// If specified, the request's tolerations.
  ///
  ///
  /// Tolerations for NoSchedule are required to allocate a device which has a taint with that effect.
  /// The same applies to NoExecute.
  ///
  /// In addition, should any of the allocated devices get tainted with NoExecute after allocation and that effect is not tolerated, then all pods consuming the ResourceClaim get deleted to evict them.
  /// The scheduler will not let new pods reserve the claim while it has these tainted devices.
  /// Once all pods are evicted, the claim will get deallocated.
  ///
  /// The maximum number of tolerations is 16.
  ///
  /// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
  ///
  /// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
  @K8sVersion { introducedIn = "1.33" }
  tolerations: Listing<DeviceToleration>?

  /// FirstAvailable contains subrequests, of which exactly one will be satisfied by the scheduler to satisfy this request.
  ///
  /// It tries to satisfy them in the order in which they are listed here.
  /// So if there are two entries in the list, the scheduler will only check the second one if it determines that the first one cannot be used.
  ///
  /// This field may only be set in the entries of DeviceClaim.Requests.
  ///
  /// DRA does not yet implement scoring, so the scheduler will select the first set of devices that satisfies all the requests in the claim.
  /// And if the requirements can be satisfied on more than one node, other scheduling features will determine which node is chosen.
  /// This means that the set of devices allocated to a claim might not be the optimal set available to the cluster.
  /// Scoring will be implemented later.
  @K8sVersion { introducedIn = "1.33" }
  firstAvailable: Listing<DeviceSubRequest>?

  /// Count is used only when the count mode is "ExactCount".
  ///
  /// Must be greater than zero.
  /// If AllocationMode is ExactCount and this field is not specified, the default is one.
  ///
  /// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
  count: Int?

  /// Name can be used to reference this request in a pod.spec.containers[].resources.claims entry and in a constraint of the claim.
  ///
  ///
  /// Must be a DNS label and unique among all DeviceRequests in a ResourceClaim.
  name: String

  /// Selectors define criteria which must be satisfied by a specific device in order for that device to be considered for this request.
  ///
  /// All selectors must be satisfied for a device to be considered.
  ///
  /// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
  selectors: Listing<DeviceSelector>?

  /// Capacity define resource requirements against each capacity.
  ///
  ///
  /// If this field is unset and the device supports multiple allocations, the default value will be applied to each capacity according to requestPolicy.
  /// For the capacity that has no requestPolicy, default is the full capacity value.
  ///
  /// Applies to each device allocation.
  /// If Count > 1, the request fails if there aren't enough devices that meet the requirements.
  /// If AllocationMode is set to All, the request fails if there are devices that otherwise match the request, and have this capacity, with a value >= the requested amount, but which cannot be allocated to this request.
  @K8sVersion { introducedIn = "1.34" }
  capacity: CapacityRequirements?
}

/// DeviceSubRequest describes a request for device provided in the claim.spec.devices.requests[].firstAvailable array.
///
/// Each is typically a request for a single resource like a device, but can also ask for several identical devices.
///
/// DeviceSubRequest is similar to Request, but doesn't expose the AdminAccess or FirstAvailable fields, as those can only be set on the top-level request.
/// AdminAccess is not supported for requests with a prioritized list, and recursive FirstAvailable fields are not supported.
class DeviceSubRequest {
  /// AllocationMode and its related fields define how devices are allocated to satisfy this subrequest.
  ///
  /// Supported values are:
  ///
  /// - ExactCount: This request is for a specific number of devices.
  ///   This is the default.
  /// The exact number is provided in the
  ///   count field.
  ///
  /// - All: This subrequest is for all of the matching devices in a pool.
  ///   Allocation will fail if some devices are already allocated,
  ///   unless adminAccess is requested.
  ///
  /// If AllocationMode is not specified, the default mode is ExactCount.
  /// If the mode is ExactCount and count is not specified, the default count is one.
  /// Any other subrequests must specify this field.
  ///
  /// More modes may get added in the future.
  /// Clients must refuse to handle requests with unknown modes.
  allocationMode: String?

  /// DeviceClassName references a specific DeviceClass, which can define additional configuration and selectors to be inherited by this subrequest.
  ///
  ///
  /// A class is required.
  /// Which classes are available depends on the cluster.
  ///
  /// Administrators may use this to restrict which devices may get requested by only installing classes with selectors for permitted devices.
  /// If users are free to request anything without restrictions, then administrators can create an empty DeviceClass for users to reference.
  deviceClassName: String

  /// If specified, the request's tolerations.
  ///
  ///
  /// Tolerations for NoSchedule are required to allocate a device which has a taint with that effect.
  /// The same applies to NoExecute.
  ///
  /// In addition, should any of the allocated devices get tainted with NoExecute after allocation and that effect is not tolerated, then all pods consuming the ResourceClaim get deleted to evict them.
  /// The scheduler will not let new pods reserve the claim while it has these tainted devices.
  /// Once all pods are evicted, the claim will get deallocated.
  ///
  /// The maximum number of tolerations is 16.
  ///
  /// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
  tolerations: Listing<DeviceToleration>?

  /// Count is used only when the count mode is "ExactCount".
  ///
  /// Must be greater than zero.
  /// If AllocationMode is ExactCount and this field is not specified, the default is one.
  count: Int?

  /// Name can be used to reference this subrequest in the list of constraints or the list of configurations for the claim.
  ///
  /// References must use the format <main request>/<subrequest>.
  ///
  /// Must be a DNS label.
  name: String

  /// Selectors define criteria which must be satisfied by a specific device in order for that device to be considered for this subrequest.
  ///
  /// All selectors must be satisfied for a device to be considered.
  selectors: Listing<DeviceSelector>?

  /// Capacity define resource requirements against each capacity.
  ///
  ///
  /// If this field is unset and the device supports multiple allocations, the default value will be applied to each capacity according to requestPolicy.
  /// For the capacity that has no requestPolicy, default is the full capacity value.
  ///
  /// Applies to each device allocation.
  /// If Count > 1, the request fails if there aren't enough devices that meet the requirements.
  /// If AllocationMode is set to All, the request fails if there are devices that otherwise match the request, and have this capacity, with a value >= the requested amount, but which cannot be allocated to this request.
  @K8sVersion { introducedIn = "1.34" }
  capacity: CapacityRequirements?
}

/// CapacityRequirements defines the capacity requirements for a specific device request.
class CapacityRequirements {
  /// Requests represent individual device resource requests for distinct resources, all of which must be provided by the device.
  ///
  ///
  /// This value is used as an additional filtering condition against the available capacity on the device.
  /// This is semantically equivalent to a CEL selector with `device.capacity[<domain>].<name>.compareTo(quantity(<request quantity>)) >= 0`.
  /// For example, device.capacity['test-driver.cdi.k8s.io'].counters.compareTo(quantity('2')) >= 0.
  ///
  /// When a requestPolicy is defined, the requested amount is adjusted upward to the nearest valid value based on the policy.
  /// If the requested amount cannot be adjusted to a valid value—because it exceeds what the requestPolicy allows— the device is considered ineligible for allocation.
  ///
  /// For any capacity that is not explicitly requested: - If no requestPolicy is set, the default consumed capacity is equal to the full device capacity
  ///   (i.e., the whole device is claimed).
  /// - If a requestPolicy is set, the default consumed capacity is determined according to that policy.
  ///
  /// If the device allows multiple allocation, the aggregated amount across all requests must not exceed the capacity value.
  /// The consumed capacity, which may be adjusted based on the requestPolicy if defined, is recorded in the resource claim’s status.devices[*].consumedCapacity field.
  requests: Mapping<String, Quantity>?
}

/// DeviceClaimConfiguration is used for configuration parameters in DeviceClaim.
class DeviceClaimConfiguration {
  /// Opaque provides driver-specific configuration parameters.
  opaque: OpaqueDeviceConfiguration?

  /// Requests lists the names of requests where the configuration applies.
  ///
  /// If empty, it applies to all requests.
  ///
  /// References to subrequests must include the name of the main request and may include the subrequest using the format <main request>[/<subrequest>].
  /// If just the main request is given, the configuration applies to all subrequests.
  requests: Listing<String>?
}

/// DeviceConstraint must have exactly one field set besides Requests.
class DeviceConstraint {
  /// DistinctAttribute requires that all devices in question have this attribute and that its type and value are unique across those devices.
  ///
  ///
  /// This acts as the inverse of MatchAttribute.
  ///
  /// This constraint is used to avoid allocating multiple requests to the same device by ensuring attribute-level differentiation.
  ///
  /// This is useful for scenarios where resource requests must be fulfilled by separate physical devices.
  /// For example, a container requests two network interfaces that must be allocated from two different physical NICs.
  @K8sVersion { introducedIn = "1.34" }
  distinctAttribute: String?

  /// MatchAttribute requires that all devices in question have this attribute and that its type and value are the same across those devices.
  ///
  ///
  /// For example, if you specified "dra.example.com/numa" (a hypothetical example!), then only devices in the same NUMA node will be chosen.
  /// A device which does not have that attribute will not be chosen.
  /// All devices should use a value of the same type for this attribute because that is part of its specification, but if one device doesn't, then it also will not be chosen.
  ///
  /// Must include the domain qualifier.
  matchAttribute: String?

  /// Requests is a list of the one or more requests in this claim which must co-satisfy this constraint.
  ///
  /// If a request is fulfilled by multiple devices, then all of the devices must satisfy the constraint.
  /// If this is not specified, this constraint applies to all requests in this claim.
  ///
  /// References to subrequests must include the name of the main request and may include the subrequest using the format <main request>[/<subrequest>].
  /// If just the main request is given, the constraint applies to all subrequests.
  requests: Listing<String>?
}
